import { dayjs } from './dateTimeUtils';
import isSameOrBefore from 'dayjs/plugin/isSameOrBefore';
import utc from 'dayjs/plugin/utc';
import { calculateShift, getShiftByCode } from './shiftCalculations';
import type { 
    ExportOptions, 
    CalendarEvent, 
    ExportResult, 
    ExportProgress 
} from '../types/export';

// Extend dayjs with required plugins
dayjs.extend(isSameOrBefore);
dayjs.extend(utc);

/**
 * Generates an RFC 5545 compliant iCalendar (.ics) file for shift schedules
 */

/**
 * Escapes text for iCalendar format according to RFC 5545
 */
function escapeICalText(text: string): string {
    return text
        .replace(/\\/g, '\\\\')  // Escape backslashes
        .replace(/;/g, '\\;')    // Escape semicolons
        .replace(/,/g, '\\,')    // Escape commas
        .replace(/\n/g, '\\n')   // Escape newlines
        .replace(/\r/g, '');     // Remove carriage returns
}

/**
 * Formats a date for iCalendar DTSTART/DTEND values
 */
function formatICalDateTime(date: dayjs.Dayjs): string {
    return date.utc().format('YYYYMMDD[T]HHmmss[Z]');
}

/**
 * Formats a date for all-day events (DTSTART;VALUE=DATE)
 */
function formatICalDate(date: dayjs.Dayjs): string {
    return date.format('YYYYMMDD');
}

/**
 * Generates a unique identifier for calendar events
 */
function generateUID(date: dayjs.Dayjs, teamNumber: number, shiftCode: string): string {
    const timestamp = date.format('YYYYMMDD');
    return `nextshift-${timestamp}-team${teamNumber}-${shiftCode}@nextshift.app`;
}

/**
 * Creates a calendar event from shift data
 */
function createCalendarEvent(
    date: dayjs.Dayjs,
    teamNumber: number,
    options: ExportOptions
): CalendarEvent | null {
    const shift = calculateShift(date, teamNumber);
    const shiftInfo = getShiftByCode(shift.code);
    
    // Skip off days if not included
    if (!options.includeOffDays && !shift.isWorking) {
        return null;
    }

    const uid = generateUID(date, teamNumber, shift.code);
    
    // Create event summary
    const summary = shift.isWorking 
        ? `${shiftInfo.name} Shift - Team ${teamNumber}`
        : `Off Day - Team ${teamNumber}`;

    // Create event description
    let description = `Team ${teamNumber} - ${shiftInfo.name}`;
    if (shift.isWorking && options.includeShiftTimes) {
        description += `\nHours: ${shift.hours}`;
    }
    if (!shift.isWorking) {
        description += '\nRest day - no shift scheduled';
    }
    description += `\nGenerated by NextShift`;

    // For working shifts, create timed events; for off days, create all-day events
    let dtStart: string;
    let dtEnd: string;
    let allDay: boolean;

    if (shift.isWorking && shift.start !== null && shift.end !== null) {
        // Timed event for working shifts
        const startTime = date.hour(shift.start).minute(0).second(0);
        let endTime = date.hour(shift.end).minute(0).second(0);
        
        // Handle overnight shifts (night shift)
        if (shift.end < shift.start) {
            endTime = endTime.add(1, 'day');
        }

        dtStart = formatICalDateTime(startTime);
        dtEnd = formatICalDateTime(endTime);
        allDay = false;
    } else {
        // All-day event for off days or shifts without specific times
        dtStart = formatICalDate(date);
        dtEnd = formatICalDate(date.add(1, 'day'));
        allDay = true;
    }

    // Set categories based on shift type
    const categories = [
        'NextShift',
        `Team${teamNumber}`,
        shift.isWorking ? 'WorkingShift' : 'OffDay',
        shiftInfo.name
    ];

    return {
        uid,
        summary: escapeICalText(summary),
        description: escapeICalText(description),
        dtStart,
        dtEnd,
        dtStamp: formatICalDateTime(dayjs()),
        allDay,
        categories
    };
}

/**
 * Generates iCalendar content from events
 */
function generateICalendarContent(events: CalendarEvent[], options: ExportOptions): string {
    const lines = [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//NextShift//NextShift Calendar Export//EN',
        'CALSCALE:GREGORIAN',
        'METHOD:PUBLISH',
        `X-WR-CALNAME:Team ${options.teamNumber} Shift Schedule`,
        'X-WR-CALDESC:NextShift team schedule export',
        `X-WR-TIMEZONE:${options.timeZone}`,
    ];

    // Add timezone component for timed events
    if (events.some(event => !event.allDay)) {
        lines.push(
            'BEGIN:VTIMEZONE',
            `TZID:${options.timeZone}`,
            'BEGIN:STANDARD',
            'DTSTART:19701025T030000',
            'RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU',
            'TZNAME:CET',
            'TZOFFSETFROM:+0200',
            'TZOFFSETTO:+0100',
            'END:STANDARD',
            'BEGIN:DAYLIGHT',
            'DTSTART:19700329T020000',
            'RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU',
            'TZNAME:CEST',
            'TZOFFSETFROM:+0100',
            'TZOFFSETTO:+0200',
            'END:DAYLIGHT',
            'END:VTIMEZONE'
        );
    }

    // Add events
    for (const event of events) {
        lines.push('BEGIN:VEVENT');
        lines.push(`UID:${event.uid}`);
        lines.push(`DTSTAMP:${event.dtStamp}`);
        lines.push(`SUMMARY:${event.summary}`);
        lines.push(`DESCRIPTION:${event.description}`);
        
        if (event.allDay) {
            lines.push(`DTSTART;VALUE=DATE:${event.dtStart}`);
            lines.push(`DTEND;VALUE=DATE:${event.dtEnd}`);
        } else {
            lines.push(`DTSTART;TZID=${options.timeZone}:${event.dtStart.replace('Z', '')}`);
            lines.push(`DTEND;TZID=${options.timeZone}:${event.dtEnd.replace('Z', '')}`);
        }
        
        if (event.categories.length > 0) {
            lines.push(`CATEGORIES:${event.categories.join(',')}`);
        }
        
        lines.push('END:VEVENT');
    }

    lines.push('END:VCALENDAR');
    
    // Join with CRLF as required by RFC 5545
    return lines.join('\r\n');
}

/**
 * Downloads a file using the browser's download API
 */
function downloadFile(content: string, filename: string): void {
    const blob = new Blob([content], { type: 'text/calendar;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up the object URL
    setTimeout(() => URL.revokeObjectURL(url), 100);
}

/**
 * Generates a filename for the export
 */
function generateFilename(options: ExportOptions): string {
    const startDate = options.startDate.format('YYYY-MM-DD');
    const endDate = options.endDate.format('YYYY-MM-DD');
    
    if (startDate === endDate) {
        return `NextShift_Team${options.teamNumber}_${startDate}.ics`;
    }
    
    return `NextShift_Team${options.teamNumber}_${startDate}_to_${endDate}.ics`;
}

/**
 * Exports shift schedule as iCalendar file
 */
export async function exportCalendar(
    options: ExportOptions,
    onProgress?: (progress: ExportProgress) => void
): Promise<ExportResult> {
    try {
        // Validate inputs
        if (options.teamNumber < 1 || options.teamNumber > 5) {
            return {
                success: false,
                error: 'Invalid team number. Must be between 1 and 5.'
            };
        }

        if (options.endDate.isBefore(options.startDate)) {
            return {
                success: false,
                error: 'End date must be after start date.'
            };
        }

        const daysDiff = options.endDate.diff(options.startDate, 'days');
        if (daysDiff > 365) {
            return {
                success: false,
                error: 'Date range cannot exceed 365 days.'
            };
        }

        onProgress?.({
            current: 0,
            total: daysDiff + 1,
            step: 'Initializing export...'
        });

        // Generate events for date range
        const events: CalendarEvent[] = [];
        let currentDate = options.startDate;
        let processedDays = 0;

        while (currentDate.isSameOrBefore(options.endDate)) {
            onProgress?.({
                current: processedDays,
                total: daysDiff + 1,
                step: `Processing ${currentDate.format('YYYY-MM-DD')}...`
            });

            const event = createCalendarEvent(currentDate, options.teamNumber, options);
            if (event) {
                events.push(event);
            }

            currentDate = currentDate.add(1, 'day');
            processedDays++;

            // Yield control to prevent blocking UI for large ranges
            if (processedDays % 50 === 0) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        onProgress?.({
            current: daysDiff + 1,
            total: daysDiff + 1,
            step: 'Generating calendar file...'
        });

        // Generate iCalendar content
        const icalContent = generateICalendarContent(events, options);
        
        // Generate filename and download
        const filename = generateFilename(options);
        downloadFile(icalContent, filename);

        return {
            success: true,
            filename,
            eventCount: events.length
        };

    } catch (error) {
        console.error('Export failed:', error);
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred during export.'
        };
    }
}

/**
 * Quick export function for current team's next 3 months
 */
export async function exportTeamSchedule(
    teamNumber: number,
    onProgress?: (progress: ExportProgress) => void
): Promise<ExportResult> {
    const startDate = dayjs().startOf('day');
    const endDate = startDate.add(3, 'months');

    const options: ExportOptions = {
        startDate,
        endDate,
        teamNumber,
        includeOffDays: true,
        includeShiftTimes: true,
        timeZone: 'Europe/Brussels' // Default timezone - could be made configurable
    };

    return exportCalendar(options, onProgress);
}